# 面向对象编程

**面向对象编程**（英语：Object-oriented programming，[缩写](https://zh.wikipedia.org/wiki/%E7%BC%A9%E5%86%99 "缩写")：OOP）是一种非常流行的[编程范式](https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B "编程范型")，它将对象(object)作为程序的基本单元，每一个对象都是类(class)的实例(instance)，类是自定义的嵌套复杂类型，它包含成员数据和成员方法，它们随着对象的实例化而生产，成员方法一般用来操纵对象的成员数据。

OOP的抽象方法将程序设计成彼此相关的对象，对象相对独立，但可以互相访问，这与传统的指令式/过程式的思路恰恰相反（将程序看作一系列[函数](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0 "函数")的集合，或者直接就是一系列对电脑下达的指令）。每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象。

OOP应用于程序设计，可以提高软件的复用性、灵活性和扩展性，许多主流编程语言都支持OOP范式，例如: C++,Java,C#,Javascript等等。我们的主角Python也支持OOP。

> 严格意义上的OOP最早出现于上世纪70年代诞生的Smalltalk语言，程序中的数据和操纵数据的方法在逻辑上是一个整体，即对象。对象可以接收消息，通过消息传递让多个对象协同，以此可以构造结构清晰的系统来降低软件整体的复杂度。当然，OOP也不是解决软件开发中所有问题的“银弹”（银弹？tan90°）。可以参考IBM360系统之父弗雷德里克·布鲁克斯所发表的论文《没有银弹：软件工程的本质性与附属性工作》和软件工程经典著作《人月神话》一书。

## 类与对象

大部分实现了OOP的编程语言，核心概念往往由三者构成：封装(Encapsulation)、继承(Inheritance)、多态(Polymorphism)。
- 封装：把一组数据和处理数据的方法组成**对象**，把行为相同的对象归纳为**类(class)**，隐藏内部细节。
- 继承：构建复杂关系，实现类的特化和泛化，达到代码可重用和可扩展特性。
- 多态：实现基于对象类型的动态分发。由继承而产生的多种子类，其对象对同一行为会做出不同的响应。

### 封装

类是一个抽象的概念，对象是其具体的实例。比如说“犬”可以看成一个类，它会包含犬的一切基础特征，比如品种、毛皮颜色(数据)以及可以吠叫(方法)的能力。而具体的每一条狗则是一个对象，它们的特征值有所差异。我们把这些基础特征封装在“犬”类的内部，并逐一设置访问权限(例如：public,private,protected)，对外隐藏细节。

> 隐藏细节的好处就在于：外部调用者无需知道狗是怎么叫的？他只需要调用犬类对象的吠叫方法，就可以让狗叫。

### 继承

继承是在类与类之间构建父子关系，子类继承父类，在设计上，这意味着子类也是一种父类，只是相比于父类，它可能更加具体。比如，“犬”类可以是“动物”类的子类，每个“动物”类都可以有一些基础特征，比如重量、尺寸等成员数据(属性)，以及吃饭、睡觉等成员方法(行为)。“犬”类也是一种动物，但“动物”类相比“犬”类更加抽象，而向下，“犬”类也可以有更具体的子类，比如“中华田园犬”类，“牧羊犬”类等等。

子类会继承父类的属性和行为，与此同时，它还可以有自己独特的属性和方法。比如“犬”类相比于“动物”类，它有自己的毛皮颜色属性。

我们通过伪代码观察父类和子类的使用：

```
// ------------------------------------------------
类 犬
开始
	公有成员:
		吠(): {...}
结束

类 中华田园犬 : 继承犬
开始
结束

类 牧羊犬 : 继承犬
开始
　　公有成员:
　　　　放牧(): {...}
结束

// ------------------------------------------------
定义 大黄 是 中华田园犬
大黄.吠()      /* 注意这里调用的是犬类的吠方法。*/
大黄.放牧()    /* 错误：中华田园犬没有放牧方法。*/

定义 小白 是 牧羊犬
小白.吠()      /* 注意这里调用的是犬类的吠方法。*/
小白.放牧()    /* 这里调用的是牧羊犬类的放牧方法。*/
```

显然，父类的好处在于让多个子类可以共享一些公共的方法，而无需为每一种具体犬类都实现一遍吠方法，减少了重复代码的编写。

> 一些编程语言还支持多重继承，即类可以同时继承多个父类，多重继承历来复杂，褒贬不一，面相初学者，就不长篇大论了。

> 事实上类与继承的这种设计，近些年饱受诟病，尤其是针对Java这种纯OOP语言。一些学者认为继承与多态的设计并没有降低系统复杂度，表面看编写的代码变少了，但本质上只是压缩而非抽象。这一论点也得到了一部分社区的认可，新生代的许多语言诸如Go, Rust已经放弃了类继承这种古典OOP的设计手法，而是换用“数据与行为分离”，即“组合”的方式。详见:[格物致知(2)——语言千百，殊途同归/#设计哲学](https://r00tk1ts.github.io/2023/06/13/%E6%A0%BC%E7%89%A9%E8%87%B4%E7%9F%A5(2)%E2%80%94%E2%80%94%E8%AF%AD%E8%A8%80%E5%8D%83%E7%99%BE%EF%BC%8C%E6%AE%8A%E9%80%94%E5%90%8C%E5%BD%92/#%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6)。

### 多态

多态这个概念实际上比较大，但是大部分采用类继承实现的OOP语言，一般提到的多态都是指动态多态，即：运行时的动态绑定能力。

> 比如C++中有静态多态和动态多态，前者一般通过CRTP等手法来实现编译期绑定，后者则是类继承虚函数的手法来实现运行时绑定。

子类继承父类的方法后，还可以对方法进行重写(override)，不同的子类可以对父类的同一个方法给出不同的实现版本，这样的方法在程序运行时就会表现出多态行为（调用相同的方法，做了不同的事情）。

一般来讲，我们通过父类类型的引用或者指针，指向一个子类类型，当访问某个被重写的方法时，会在运行时调用子类的对应方法，而非父类（如果有重写的话）。通过这种方式，我们能够做到基于对象类型的动态分发，提高了编写抽象代码的灵活性。

多态是面向对象编程中最精髓的部分，也是对初学者来说最难以理解和灵活运用的部分。

> override和overwrite这两个术语中文一般都翻译成重写，但在特定的编程语言中，两者的语义是不一样的，比如在C++中，override是指以具有相同签名的函数覆盖父类中的虚函数，而overwrite则是用签名不一致的同名函数覆盖父类中的虚函数，或是签名相同的函数覆盖父类中的非虚函数。这两个词经常被混淆。

# Class in Python

Python中的类和许多编程语言一样，都使用`class`作为关键字。Python支持多重继承、派生类的override（以实现多态），类可以封装任意数量和类型的数据、以及成员方法。

Python当中所有的成员(数据和方法)都是公开的(即Java,C++中的共有`public`)，所有成员函数都可以被override(即C++中的虚函数)。

> Python class的设计类似于C++和Modula-3中类的结合体。

## 类的定义

最简单的类定义语法如下：

```python
class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
```

类似函数定义语法，必须先定义才能够使用。当进入类定义时，将创建一个局部作用域，所有对局部变量的赋值都是在这个作用域之内。

举个例子，我们定义一个`MyClass`类：

```python
class MyClass:
	"""A simple example class"""
	# 定义成员方法f，首个参数self固定，表示调用的对象本身
	def f(self):
		return 'hello world'
```

## 类的实例化与属性引用

对已创建好的类来说，实例化对象使用函数表示法，可以把类名看作是一个不带参数的函数，返回一个对象实例：

```python
# 构造一个MyClass类对象x
x = MyClass()

# 打印'hello world'
print(x.f())
```

这里对成员方法的访问，是通过`.`操作符：对象`.`方法。



# 附录

- [面向对象程序设计](https://zh.wikipedia.org/zh-cn/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)
- [Python Tutorial-Class](https://docs.python.org/zh-cn/3/tutorial/classes.html)